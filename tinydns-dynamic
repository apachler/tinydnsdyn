#!/usr/bin/python

# Copyright 2008 Felix McCoey <felix.mccoey@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301  USA


import os
import shutil
import socket
import hashlib
from optparse import OptionParser

def main():
  usage = "usage: %prog [options] password"
  parser = OptionParser(usage=usage)
  parser.add_option("-s", "--server", action="store_true", dest="server",
      help="act as aserver, otherwise be a client")
  parser.add_option("-d", "--data-dir", dest="data_dir",
      help="[server] absolute path to the tinydns data directory")
  parser.add_option("-t", "--ttl", dest="ttl",
      help="[server] Time To Live")
  parser.add_option("-n", "--hostname", dest="ddns_hostname",
      help="[client] your desired DDNS hostname")
  parser.add_option("-r", "--remote-server", dest="ddns_server",
      help="[client] the DDNS server hostname")
  parser.add_option("-p", "--port", dest="ddns_port",
      help="the port to use")
  parser.set_defaults(data_dir="/var/services/tinydns/root", ddns_port=5300, ttl=60)
  (options, args) = parser.parse_args()
  if len(args) != 1:
    parser.error("You need to supply a password")
    exit(-1)
  else:
    password = args[0]

  def processDDNSRequest(address, hostname):
    result = 0
    try: data_tmp_file = open(data_tmp_path,"w")
    except: 
      print "ERROR: Unable to create temporary data file"
      exit(-1)

    for line in data_file:
      print line
      if line[0] not in ['+','=','^',"'",'C']:
        data_tmp_file.write(line)
        continue
      host,old_ip,old_ttl = line.split(":",2)
      # i think these prefixes should all work?!
      if host.lstrip("+=^'C") == hostname:
        if old_ip != address:
          data_tmp_file.write("%s:%s:%s\n" % (host,address,options.ttl) )
          result = 1
      else:
        data_tmp_file.write(line)
    data_tmp_file.close()
    return result

    
  def createHash(hostname):
    return hashlib.sha1("%s%s" % (hostname.strip(),password)).hexdigest()

  # main selection between server and client
  if options.server:
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("",options.ddns_port))
    print "Server started on port", options.ddns_port
    os.chdir(options.data_dir)
    while 1:
      # receive data from client, "hostname|hash"
      data, addr = sock.recvfrom(1024)
      rq_hostname, rq_hsh = data.split("|",1)
      if rq_hsh == createHash(rq_hostname):
        data_path = os.path.join(options.data_dir, "data")
        data_tmp_path = os.path.join(options.data_dir, "data.tmp")
        try: data_file = open(data_path,"r")
        except: 
          print "ERROR: Unable to open tinydns data file"
          exit(-1)
        result = processDDNSRequest(addr[0],rq_hostname)
        if result == 1:
          # now overwrite data file with temp one
          try:
            shutil.move(data_tmp_path, data_path)
            print "CHANGED: %s = %s" % (rq_hostname, addr[0])
          except: 
            print "ERROR: Unable to overwrite data file"
          # now run the tinydns-data prog
          if (os.system("tinydns-data") == -1):
            print "ERROR: Unable to execute tinydns-data program"
        
        elif result == 0:
          print "NO CHANGE: %s = %s" % (rq_hostname, addr[0])
        else:
          print "FAILED: Invalid hostname request '%s'" % rq_hostname
        data_file.close()
      else:
        print "FAILED: Authentication failed"

  else:
    # create and connect the socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    data = "%s|%s" % (options.ddns_hostname, createHash(options.ddns_hostname))
    sock.sendto(data, (options.ddns_server,options.ddns_port))

if __name__ == "__main__":
  main()
