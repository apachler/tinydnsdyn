#!/usr/bin/python2

# Copyright 2011 Felix Hanley <felix@seconddrawer.com.au>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as 
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301  USA

import sys
import os
import shutil
import base64
import crypt
import urlparse
import SimpleHTTPServer
import SocketServer
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from SocketServer import ThreadingMixIn
import threading
from optparse import OptionParser

class RequestHandler(BaseHTTPRequestHandler):

    def auth_headers(self):
        self.send_header('Content-type', 'text/html')
        self.send_header('WWW-Authenticate', 'Basic realm=\"Test\"')

    def do_HEAD(self):
        self.send_response(200)
        self.auth_headers()
        self.end_headers()

    def do_GET(self):
        self.auth = Authorizer()
        self.datafile = DataFile()
        auth_header= self.headers.getheader('Authorization')
        if auth_header:
            passhash = auth_header.replace('Basic ','',1).strip()
            username,password = base64.b64decode(passhash).split(':',1)
        query = urlparse.parse_qs(self.path.lstrip("/?"))

        if 'myip' in query: address = query['myip']
        else: address = self.client_address[0]

        if auth_header:
            for hostname in query['hostname'][0].split(','):
                if self.auth.check(username, password, hostname):
                    print "AUTH: success"
                    # make the changes to the file
                    result = self.datafile.update(address, hostname)
                    if result == 1:
                        print "CHANGED: %s = %s" % (hostname, address)
                    elif result == 0:
                        print "NO CHANGE: %s = %s" % (hostname, address)
                    else:
                        print "FAILED: client %s invalid hostname request '%s'" % (address, hostname)
                else:
                    print "AUTH: failed"
            self.datafile.commit()

        else:
            self.send_response(401)
            self.auth_headers()
            self.end_headers()
            print "AUTH: none"


class Authorizer:
    """A class for manipulating htpasswd files."""

    def __init__(self):
        self.filename = options.passfile
        self.entries = []
        if os.path.exists(self.filename):
            lines = open(self.filename, 'r').readlines()
            for line in lines:
                entry = [x.strip() for x in line.split(':',2)]
                self.entries.append(entry)
        else:
            raise Exception("unable to find password file: %s" % self.filename)

    def check(self, username, password, fqdn):
        for entry in self.entries:
            if entry[0] == username:
                if entry[1] == crypt.crypt(password, entry[1]):
                    if len(entry) == 2 or fqdn in entry[2].split(','):
                        return True

        return False


class DataFile:

    def __init__(self):
        self.datafile_path = os.path.join(options.root, "data")
        self.tmpfile_path = os.path.join(options.root, "data.tinydnsdyn.tmp")
        if os.path.exists(self.datafile_path):
            try: self.datafile = open(self.datafile_path,"r")
            except:
                raise Exception("unable to open tinydns data file: %s" %
                        self.datafile_path)

            try: self.tmpfile = open(self.tmpfile_path,"w")
            except:
                raise Exception("unable to create temporary data file: %s" %
                        tmpfile_path)
        else:
            raise Exception("unable to find data file: %s" % self.datafile_path)

    def update(self, address, hostname):
        result = -1
        for line in self.datafile:
            if line[0] in ['+','=']:
                fields = line.split(":",2)
                # i think these prefixes should work?!
                if fields[0].lstrip("+=.*") == hostname:
                    if fields[1] != address:
                        line = "%s:%s:%s\n" % (fields[0],address,options.ttl)
                        result = 1
                    else:
                        result = 0
            self.tmpfile.write(line)
        self.tmpfile.close()
        return result

    def commit(self):
        # overwrite data file with temp one
        try: shutil.move(self.tmpfile_path, self.datafile_path)
        except:
            raise Exception("unable to overwrite data file: %s" %
                    self.datafile_path)
        # now run the tinydns-data prog
        if (os.system("cd %s && make -s" % options.root) != 0):
            raise Exception("problem executing Makefile")
    

def main():

    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("-r", "--root", dest="root",
            help="absolute path to the tinydns data directory")
    parser.add_option("-t", "--ttl", dest="ttl",
            help="default Time To Live")
    parser.add_option("-a", "--address", dest="address",
            help="the address to bind to (default: all)")
    parser.add_option("-p", "--port", dest="port",
            help="the port to listen on (default: 8080)")
    parser.add_option("-f", "--passfil", dest="passfile",
            help="the password file (default: ./htpasswd)")

    # defaults
    parser.set_defaults(root="/var/services/tinydns/root", address='',
            port=8080, ttl=60, passfile='htpasswd')
    global options
    (options, args) = parser.parse_args()


    httpd = HTTPServer((options.address, options.port), RequestHandler)
    httpd.serve_forever()


if __name__ == "__main__":
    try: main()
    except Exception as strerror:
        print "tinydnsdyn: %s" % format(strerror)
